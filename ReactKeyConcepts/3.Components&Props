# Chapter 3: Components & Props

## üìñ Understanding Props

**Props** (short for "properties") are the mechanism that allows React components to receive data from their parent components. Props make components reusable and dynamic by allowing them to render different content based on the data they receive.

---

## üéØ Basic Props Example

```jsx
<ul> 
    <GoalItem id="g1" title="Finish the book!" />
    <GoalItem id="g2" title="Learn all about React!" />
</ul>

function GoalItem(props) {
    return <li>{props.title} (ID: {props.id})</li>;
}
```

> **Note**: It's optional to call the parameter `props`, but it's been a tradition in the React community.

---

## üì¶ Props Can Hold Any Data Type

**Important fact**: React props can accept **any JavaScript data type** - not just strings! You can pass numbers, booleans, arrays, objects, functions, and even other React components as prop values.

### üéØ Data Types You Can Pass as Props:

```jsx
// Strings, Numbers, Booleans
<UserProfile 
    name="John Doe"           // String
    age={28}                  // Number
    isActive={true}           // Boolean
/>

// Arrays
<ShoppingList 
    items={["apples", "bananas", "oranges"]}
    quantities={[3, 2, 5]}
/>

// Objects
<UserSettings 
    preferences={{
        theme: "dark",
        language: "en",
        notifications: true
    }}
    address={{
        street: "123 Main St",
        city: "New York",
        zipCode: "10001"
    }}
/>

// Functions
<Button 
    onClick={handleClick}
    onHover={handleMouseEnter}
/>

// Even other React components!
<Layout 
    header={<Header />}
    sidebar={<Sidebar />}
/>
```

### üîß Working with Array Props:

```jsx
function TodoList(props) {
    return (
        <ul>
            {props.todos.map((todo, index) => (
                <li key={index}>
                    {todo.title} - {todo.completed ? "‚úÖ" : "‚è≥"}
                </li>
            ))}
        </ul>
    );
}

// Usage
<TodoList 
    todos={[
        { title: "Learn React", completed: true },
        { title: "Build an app", completed: false },
        { title: "Master props", completed: false }
    ]}
/>
```

### üèóÔ∏è Working with Object Props:

```jsx
function UserCard(props) {
    return (
        <div className="user-card">
            <h2>{props.user.name}</h2>
            <p>Age: {props.user.age}</p>
            <p>Email: {props.user.contact.email}</p>
            <p>Phone: {props.user.contact.phone}</p>
            <div>
                <strong>Preferences:</strong>
                <p>Theme: {props.user.preferences.theme}</p>
                <p>Language: {props.user.preferences.language}</p>
            </div>
        </div>
    );
}

// Usage
<UserCard 
    user={{
        name: "Alice Johnson",
        age: 32,
        contact: {
            email: "alice@example.com",
            phone: "555-0123"
        },
        preferences: {
            theme: "light",
            language: "en"
        }
    }}
/>
```

### ‚ö° Pro Tips for Complex Props:

#### 1. **Use Curly Braces for Non-String Values**
```jsx
// ‚ùå Wrong - passes string "25" instead of number 25
<Component age="25" />

// ‚úÖ Correct - passes number 25
<Component age={25} />

// ‚úÖ Correct - passes actual array
<Component items={["item1", "item2"]} />
```

#### 2. **Extract Complex Objects for Readability**
```jsx
// Instead of inline objects (can get messy)
<UserCard user={{ name: "John", age: 30, email: "john@example.com" }} />

// Extract to variables for cleaner code
const userData = {
    name: "John",
    age: 30,
    email: "john@example.com"
};

<UserCard user={userData} />
```

#### 3. **Spread Operator with Objects**
```jsx
const userProps = {
    name: "Sarah",
    age: 25,
    isActive: true
};

// Instead of passing each prop individually
<UserProfile name={userProps.name} age={userProps.age} isActive={userProps.isActive} />

// Use spread operator
<UserProfile {...userProps} />
```

#### 4. **Two Ways to Pass Multiple Related Values**

You have **two main approaches** when passing multiple related pieces of data:

**Option 1: Individual Props (Separate Attributes)**
```jsx
<Product title="A book" price={29.99} id="p1" />

function Product(props) {
    return (
        <div>
            <h3>{props.title}</h3>
            <p>Price: ${props.price}</p>
            <p>ID: {props.id}</p>
        </div>
    );
}
```

**Option 2: Single Object Prop (Grouped Data)**
```jsx
const productData = {
    title: 'A book', 
    price: 29.99, 
    id: 'p1'
};

<Product data={productData} />

function Product(props) {
    return (
        <div>
            <h3>{props.data.title}</h3>
            <p>Price: ${props.data.price}</p>
            <p>ID: {props.data.id}</p>
        </div>
    );
}
```

**When to Use Each Approach:**
- **Individual Props**: When you need flexibility and each piece of data is independent
- **Object Props**: When data naturally belongs together (like from an API response)
- **Both are valid**: Choose based on your specific use case and team preferences

---

## üîç Props vs Props.children: The Complete Guide

### üè∑Ô∏è Regular Props
**How to pass**: As attributes on the component tag  
**What they're for**: Configuration, data, and settings

```jsx
// Passing regular props
<UserCard 
    name="John Doe" 
    age={28} 
    email="john@example.com" 
    isOnline={true}
    avatar="/images/john.jpg"
/>

// Receiving regular props
function UserCard(props) {
    return (
        <div className="user-card">
            <img src={props.avatar} alt={`${props.name}'s avatar`} />
            <h3>{props.name}</h3>
            <p>Age: {props.age}</p>
            <p>Email: {props.email}</p>
            <span className={props.isOnline ? "online" : "offline"}>
                {props.isOnline ? "üü¢ Online" : "üî¥ Offline"}
            </span>
        </div>
    );
}
```

### üë∂ Props.children
**How to pass**: As content between opening and closing tags  
**What they're for**: JSX content, nested components, flexible layouts

```jsx
// Passing children props
<Modal title="Confirm Action" isOpen={true}>
    <h2>Delete Item?</h2>
    <p>This action cannot be undone. Are you sure you want to proceed?</p>
    <div className="button-group">
        <button className="btn-danger">Delete</button>
        <button className="btn-secondary">Cancel</button>
    </div>
</Modal>

// Receiving children props (+ regular props)
function Modal(props) {
    return (
        <div className={`modal ${props.isOpen ? 'open' : 'closed'}`}>
            <div className="modal-header">
                <h1>{props.title}</h1>
            </div>
            <div className="modal-content">
                {props.children}  {/* All the JSX between <Modal> tags goes here */}
            </div>
        </div>
    );
}
```

---

## üÜö Key Differences

| Aspect | Regular Props | Props.children |
|--------|---------------|----------------|
| **How to Pass** | `<Component prop="value" />` | `<Component>content</Component>` |
| **Data Type** | Strings, numbers, booleans, functions, objects | JSX elements, components, text |
| **Purpose** | Configuration and data | Content to be rendered |
| **Flexibility** | Fixed key-value pairs | Any JSX structure |
| **Access** | `props.propName` | `props.children` |

---

## üé® Use Cases & When to Use Each

### üîß Use Regular Props When:

1. **Configuring component behavior**
```jsx
<Button size="large" color="primary" disabled={false} onClick={handleClick} />
```

2. **Passing simple data**
```jsx
<ProductCard name="iPhone" price={999} inStock={true} rating={4.5} />
```

3. **Component settings**
```jsx
<Image src="photo.jpg" width={300} height={200} lazy={true} />
```

### üéÅ Use Props.children When:

1. **Creating wrapper/container components**
```jsx
<Card>
    <h3>Product Title</h3>
    <p>Product description goes here...</p>
    <button>Add to Cart</button>
</Card>
```

2. **Building layout components**
```jsx
<PageLayout>
    <Header />
    <MainContent />
    <Footer />
</PageLayout>
```

3. **Creating reusable UI patterns**
```jsx
<Tooltip message="This is a helpful tip">
    <button>Hover me!</button>
</Tooltip>
```

---

## üîÑ Combining Both: The Power Pattern

You can use **both regular props AND children** in the same component:

```jsx
// Using both regular props and children
<AlertBox type="warning" dismissible={true} onClose={handleClose}>
    <h4>‚ö†Ô∏è Warning!</h4>
    <p>Your session will expire in 5 minutes.</p>
    <button>Extend Session</button>
</AlertBox>

// Component that uses both
function AlertBox(props) {
    return (
        <div className={`alert alert-${props.type}`}>
            {props.children}  {/* The JSX content */}
            {props.dismissible && (
                <button className="close-btn" onClick={props.onClose}>
                    ‚úï
                </button>
            )}
        </div>
    );
}
```

---

## üéØ Best Practices

### ‚úÖ Do:
- Use **regular props** for component configuration and data
- Use **children** for flexible content and layouts
- Combine both when you need configuration AND flexible content
- Keep prop names descriptive and consistent

### ‚ùå Avoid:
- Passing large JSX structures as regular props (use children instead)
- Using children for simple string values (use regular props)
- Overusing either pattern when the other would be clearer

---

## üöÄ Real-World Example: Blog Post Component

```jsx
// Perfect combination of props and children
<BlogPost 
    title="Learning React Props"
    author="Jane Doe"
    publishDate="2024-01-15"
    tags={["react", "javascript", "frontend"]}
    readTime={5}
>
    <p>Welcome to this comprehensive guide on React props...</p>
    
    <h2>What are Props?</h2>
    <p>Props are the way we pass data between components...</p>
    
    <CodeBlock language="jsx">
        {`<Component prop="value" />`}
    </CodeBlock>
    
    <p>And that's how props work in React!</p>
</BlogPost>

function BlogPost(props) {
    return (
        <article className="blog-post">
            <header>
                <h1>{props.title}</h1>
                <div className="meta">
                    <span>By {props.author}</span>
                    <span>{props.publishDate}</span>
                    <span>{props.readTime} min read</span>
                </div>
                <div className="tags">
                    {props.tags.map(tag => (
                        <span key={tag} className="tag">#{tag}</span>
                    ))}
                </div>
            </header>
            
            <main className="content">
                {props.children}  {/* All the blog content goes here */}
            </main>
        </article>
    );
}
```

---

## üîÑ Unused Props: A Common Reality

### ‚úÖ You Can Pass Props Even If You Don't Use Them

**Important fact**: React allows you to pass props to components even if those props are never used. This is perfectly valid and very common in real applications.

```jsx
// Passing multiple props
<UserCard 
    name="John Doe" 
    age={28} 
    email="john@example.com" 
    phone="123-456-7890"        // Not used
    address="123 Main St"       // Not used
    isOnline={true}            // Not used
/>

// Component only uses some props, ignores others
function UserCard(props) {
    return (
        <div className="user-card">
            <h3>{props.name}</h3>
            <p>Age: {props.age}</p>
            {/* phone, email, address, isOnline are ignored but still passed */}
        </div>
    );
}
```

### üéØ Common Scenarios:

#### 1. **Future-Proofing Components**
```jsx
// You might not use priority/dueDate now, but plan to later
<Task 
    id="task1" 
    title="Complete project" 
    priority="high"           // Not used yet
    dueDate="2024-01-15"     // Not used yet
/>

function Task(props) {
    return <li>{props.title}</li>;  // Only using title for now
}
```

#### 2. **API Data Spreading**
```jsx
// API returns lots of user data
const userData = {
    id: 1,
    name: "Alice",
    email: "alice@example.com",
    phone: "555-0123",
    address: "123 Oak St",
    birthdate: "1990-05-15",
    preferences: { theme: "dark" },
    lastLogin: "2024-01-10"
};

// Pass all data, use only what you need
<SimpleUserCard {...userData} />

function SimpleUserCard(props) {
    return (
        <div>
            <h2>{props.name}</h2>
            <p>{props.email}</p>
            {/* All other props are unused but harmless */}
        </div>
    );
}
```

#### 3. **Component Evolution**
```jsx
// Version 1: Simple button (ignores styling props)
function Button(props) {
    return <button>{props.children}</button>;
}

// Version 2: Enhanced button (now uses previously ignored props)
function Button(props) {
    return (
        <button 
            className={`btn btn-${props.color} btn-${props.size}`}
            variant={props.variant}
        >
            {props.children}
        </button>
    );
}

// Same usage works for both versions!
<Button color="blue" size="large" variant="outline">
    Click Me
</Button>
```

### üìù Key Points About Unused Props:

- ‚úÖ **No Errors**: React won't complain about unused props
- ‚úÖ **Future-Proof**: Props are available when you need them later
- ‚úÖ **Flexible**: Allows component evolution without breaking parent components
- ‚úÖ **Common Practice**: Happens frequently in real applications
- ‚ö†Ô∏è **Memory**: Unused props still exist in memory (usually negligible impact)

---

## üí° Key Takeaways

1. **Props = Data In**: Components receive data through props
2. **Two Ways to Pass**: Attributes (regular props) or content (children)
3. **Regular Props**: For configuration, settings, and simple data
4. **Children**: For flexible JSX content and layouts
5. **Combine Both**: Most powerful pattern for reusable components
6. **Data Flows Down**: Props enable parent-to-child communication
7. **Unused Props Are OK**: You can pass props even if components don't use them

Props are the foundation of component composition in React - master them, and you'll build amazing, reusable components! üéâ